= Pi4Micronaut Documentation
:source-highlighter: rouge
:rouge-style: thankful_eyes
:stylesheet: style.css
:docinfo: shared
:icons: font
:doctype: book
:title: Pi4Micronaut Documentation
:toc: left
:toclevels: 3
:sectanchors:
:sectnums:

toc::[]

== Introduction
Welcome to the **Pi4Micronaut Documentation**!

Pi4Micronaut is an Open Source Java library which utilizes the Micronaut Framework and Pi4J to streamline the process of creating custom IoT applications that require hardware connectivity to Raspberry Pi's.

By reading through our documentation, you will learn how to implement our library into your application.

=== Currently Supported Hardware

If you plan on creating an application using any of the hardware components listed below, then our library is perfect for you!

We plan on offering support for many more hardware components in the future. If you have a hardware component you would like to use but can't find, feel free to checkout how you can add support for it under "Contributing to the Library"

* Push Button
* Slide Switch
* Rotary Encoder
* RFID Scanner
* LEDs
* RGB LEDs
* LCDs
* Photosensors

=== Example Applications

If you're curious about what Pi4Micronaut is capable of, check out some of the working applications created using our library.

==== Remote Mointoring Check-In System
https://github.com/oss-slu/SLU_OSS_CheckIn

== Adding to/Creating an Application

TODO: outline how to create a basic applicaton like we did for the start of the check-in system +
TODO: outline how someone should add our jar to their exsisting application

== Using the library

TODO: outline the most basic use cases of the library, tbh now sure how this differs from the section above

== Components

=== Communicating with a Hardware Component

TODO: outline the use and access of application.yaml for an app +
TODO: Consolidate the format and include examples of how each comm type is used

==== Digital Input
To define in application.yaml add digital-input as a field under pi4j, then add each component under digital-input
Each component will need

* name: Name of the component
* address: GPIO pin associated with component
* debounce:
* pull: Either PULL_UP or PULL_DOWN depending on component
* provider: pigpio-digital-input

[source,yaml]
----
include::../../../../components/src/main/resources/application.yml[tags=digitalInput]
----

<.> Component Identifier (Used in @Named annotations)
<.> Component Name
<.> Address of connected GPIO pin
<.> Debounce value
<.> Pull value (PULL_UP or PULL_DOWN)
<.> Provider (pigpio-digital-input)

==== Digital Output
To define in application.yaml add digital-output as a field under pi4j, then add each component under digital-input
Each component will need

* name: Name of the component
* address: GPIO pin associated with component
* initial: Initial value, either LOW or HIGH
* shutdown: State to take when program successfully shuts down properly, either LOW or HIGH
* provider: pigpio-digital-output

[source,yaml]
----
include::../../../../components/src/main/resources/application.yml[tags=digitalOutput]
----
<1> Component Identifier (Used in @Named annotations)
<2> Component Name
<3> Address of connected GPIO pin
<4> Value to have on shutdown (HIGH = Off, LOW = On)
<5> Value to have on startup
<6> Provider (pigpio-digital-output)

==== Multipin Configurations

Multipin components are unique in that they require several of the same type of pin in order to function properly.
Each class of multipin component (Digital Input, PWM), is declared slightly differently in the application.yaml file

.Example Multipin Digital Input declaration
[source, yaml]
----
include::../../../../components/src/main/resources/application.yml[tags=multiInput]
----
<.> Top level field for multipin digital inputs (equivlent of digital-output declaration)
<.> Component Identifier (Used in @Named annotations)
<.> Component Name
<.> Addresses for each pin (Each component has a specific order outlined in the component description)
<.> Debounce values for each pin (same order as above)
<.> Pull values for each pin (same order as above)
<.> Shutdown value (All pins have the same shut down)
<.> Startup value (All pins have the same start up)
<.> Provider (All pins have the same provider)

.Example Multipin PWM declaration
[source, yaml]
----
include::../../../../components/src/main/resources/application.yml[tags=multipwm]
----
<.> Top level field for multipin PWMs (equivlent of digital-output declaration)
<.> Component Identifier (Used in @Named annotations)
<.> Component Name
<.> Addresses for each pin (Each component has a specific order outlined in the component description)
<.> PWM types for each pin (same order as above)
<.> Provider (All pins have the same provider)
<.> Startup values (Same order as above)
<.> Shutdown values (Same order as above)


==== PWM
To define in application.yaml add digital-input as a field under pi4j, then add each component under digital-input
Each component will need

* name: Name of the component
* address: GPIO pin associated with component
* pwmType: Either SOFTWARE or HARDWARE based upon which type of PWM you wish to use
* provider: pigpio-pwm

[source,yaml]
----
include::../../../../components/src/main/resources/application.yml[tags=pwm]
----
<1> Component Identifier (Used in @Named annotations)
<2> Component Name
<3> Address of connected GPIO pin
<4> PWM Type (HARDWARE or SOFTWARE)
<5> Provider (pigpio-digital-output)
<6> Value to have on start up
<7> Value to have on shut down

==== SPI

[source,yaml]
----
include::../../../../components/src/main/resources/application.yml[tags=spi]
----
<1> Component Identifier (Used in @Named annotations)
<2> Component Name
<3> TO DO: Figure out what this address is
<4> Baud rate
<5> Address of GPIO Reset pin

TODO: add SPI information

==== I2C

[source,yaml]
----
include::../../../../components/src/main/resources/application.yml[tags=i2c]
----
<1> Component Identifier (Used in @Named annotations)
<2> Component Name
<3> Device bus (0 or 1)
<4> Device address

TODO: add I2C information

=== Input Components

==== Push Button

include::inputComponents/pushbutton.adoc[]

==== Slide Switch

include::inputComponents/slideSwitch.adoc[]

==== Rotary Encoder

include::inputComponents/rotaryEncoder.adoc[]

==== RFID Scanner

include::spiComponents/rfidScanner.adoc[]

==== Photosensor

TODO: add in photosensor support docs

=== Output Components

==== LED

include::outputComponents/led.adoc[]

==== RGB LED

include::pwmComponents/rgbLed.adoc[]
==== LCD

include::i2cComponents/lcdScreen.adoc[]

== Contributing to the Library

TODO: outline how someone can contribute to our library

=== MultiPin Components

==== Digital Input
All the supporting code for being able to create multipin Digital Input components has previously been added
to the library. As such, adding support for new Digital Input components should prove fairly straightforward.

First, the helper class for the component should be created, and each Digital Input pin declared as a private
field within the class.
The constructor should accept a MultipinConfiguration object as an argument, and access the components within it
by making use of the MultipinConfiguration getComponents method which will return a list of Digital Input objects.
Each object in this list should then be assigned to the appropriate Digital Input pin previously declared as a field
in the new helper class.

.Example Multipin Digital Input Constructor
[source, java]
----
include::../../main/java/com/opensourcewithslu/inputdevices/RotaryEncoderHelper.java[tags=const_logic]
----
<.> Constructor definition which accepts a MultipinConfiguration argument
<.> Accessing the DigitalInput components from the MultipinConfiguration object
<.> Setting the first value to the sw pin
<.> Setting the second value to the clk pin
<.> Setting the third value to the dt pin

After appropriately creating the constructor development of support for the new component can proceed as outlined
in the standard "Contributing to the Library" section.

==== PWM

==== SCI, I2C
SCI and I2C devices are not multipin components in the same way as a multipin digital input or output.
While they do each use multiple pins, SCI and I2C devices use pins dedicated for SCI and I2C communications
and are not declared in the same manner. As such, these types of components can all be added to the library
as outlined in the standard "Contributing to the Library" section.
